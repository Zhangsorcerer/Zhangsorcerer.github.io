# 1. 数组

## 1.1 概述

数组是相同数据类型的多个数据的容器。

这些元素按**线性顺序排列**。所谓线性顺序是指除第一个元素外，每一个元素都有唯一的前驱元素；除最后一个元素外，每一个元素都有唯一的后继元素。（一个跟一个顺序排列）

即：数组创建时要**明确声明将存储的数据类型**是什么，以及，需要**明确声明数组有多长**（能存储多少个数据）。数组的长度在创建以后，其在内存中的空间就申请完毕了，数组的长度在创建后不能更改（除非使用动态扩容算法进行扩容，其原理实际上是再创建一个容量更大的数组，将原数组的数据放进去）。

每个数组元素均有一个下标，表示第0个、第1个、第2个... 元素。

创建容量为n的数组，即相当于声明了n个同类型变量。

## 1.2 创建数组的格式

```java
// 常用格式1. 创建数组的同时，指定数组中的内容
// 数据类型[] 数组名称 = {数据1, 数据2, 数据3, ... 数据n};
int[] ages = {10, 11, 12, 13, 14};

// 常用格式2. 创建数组并指定长度，不指定数组中的内容
// 数据类型[] 数组名称 = new 数据类型[数组长度(int)];
// 数组长度通过int数据类型指定
int[] ages2 = new int[10];
```

## 1.3 通过下标操作数组数据的方式

```java
// 1. 给数组某个下标赋值
// 数组名称[下标] = 值;
ages[0] = 100;
// 2. 从数组某个下标取值
// 数组名称[下标]
System.out.println(ages[0]);
// 未存储数据时，其元素值为其类型的默认值
System.out.println(ages2[0]);
// 输出为0，因为int的默认值为0
```

## 1.4 获取数组的长度

```java
// 数组名称.length （int类型）
// 注意length是长度属性，并非调用方法，后面无括号
// 数组中能存储几个数据，长度就是几
for(int index=0; index<ages.length ; index++){
    // index: 0 1 2 3 4
    System.out.println(ages[index]);
}
// 以上操作称为数组的遍历
```

## 1.5 数组不常用的创建方式

```java
// 1. 创建数组，但不初始化
// 数据类型[] 数组名;
int[] nums;
// 注意此时若要初始化该数组，只能用new：
nums = new int[10];
// 大括号方式实际上是数组的简写格式，只能用于声明数组并赋值时

// 2. 创建数组，并指定数组中的内容
// 数据类型[] 数组名称 = new 数据类型[]{元素1, 元素2, 元素3, ... 元素n};
int[] ages = new int[] {11, 12, 13, 14};
```

## 1.6 数组常见问题

1. 数组下标越界问题：超出下标范围边界

   ```java
   int[] nums = {10,11,12,13,14};
   System.out.println(nums[5]);
   // 将会产生java.lang.ArrayIndexOutOfBoundsException
   ```

2. 空指针问题：

   ```java
   int[] nums;
   System.out.println(nums);
   // 如果声明在成员变量中，其默认值为null
   ```

   空指针问题一般出现在引用数据类型，其意义为占用内存的名称和值未绑定，或名称指向的值不存在，将会引发java.lang.NullPointerException。

# 2. 数组常用算法

## 2.1 寻找最大或最小值

```java
int[] nums = {10,30,40,90,50,0};
// 1.创建一个变量，用于存储遍历数组时发现的最大值
int n = nums[0];
// 注意：该变量初始值建议为数组的第一个数值，用于比较大小，若初始化为0，则若数组中元素存在负值，结果将不准确。
// 2. 遍历数组：循环取出数组中的每一个元素
for(int i=1; i<nums.length; i++){
    // 将数组中的每一个元素的值与n比较，如果比n大，则将n的值赋值为该元素的值
    n = n>nums[i]?n:nums[i];
    // 若寻找最小值则：
    // n = n<nums[i]?n:nums[i];
}
// 从1开始因为上面n的初始值为数组的第一个值
System.out.println(n);
```

## 2.2 冒泡排序

因为最小（或最大）的元素会经由交换慢慢“浮”到数列的顶端（降序或升序），就如同水中的气泡最终会上浮到顶端一样，故名“冒泡排序”。

### 2.2.1 原理

- 比较相邻的元素。如果第一个比第二个大，就交换它们；
- 对每一对相邻元素都做同样的工作，从第一对到最后一对。最后的元素将会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 

### 2.2.2 分析

- 比较的轮数：length - 1
- 第一轮比较 length-1 次
- 第二轮比较 length-2 次
- 第n轮比较 length-n 次

### 2.2.3 口诀

- 升序排序

  N个数字来排队

  两两相比小靠前

  外层循环length-1

  内层循环length-i-1（i从0开始）

- 降序排序

  N个数字来排队

  两两相比大靠前

  外层循环length-1

  内层循环length-i-1（从0开始）

### 2.2.4 代码

```java
int[] nums = {20,15,18,13,30,60};
int tmp;
// 外层循环控制比较的轮数
// 外层循环次数 length-1
for(int i=0; i<nums.length-1; i++){
    // 内层循环控制每轮比较的次数
    // 第n轮（n从0开始），比较次数为length-n-1
    for(int j=0; j<nums.length-i-1; j++){
        if(nums[j]>nums[j+1]){
            // 两两相比左边较大，满足移动条件
            tmp = nums[j];
            nums[j] = nums[j+1];
            nums[j+1] = tmp;
        }
    }
}

// 排序已经完成，下面是遍历打印查看的过程
for(int i=0; i<nums.length; i++){
    System.out.println(nums[i]);
}
```

## 2.3 二分查找

### 2.3.1 概述

二分查找也称折半查找(Binary Search)，它是一种效率较高的查找方法。但是，二分查找要求数组数据**必须采用顺序存储结构有序排列**。

数据量越大，二分查找的效率越高。

### 2.3.2 原理

首先，假设数组中元素是按升序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功；否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数组，否则进一步查找后字数组。

重复以上过程，直到找到满足条件的数据，则表示查找成功；直到子数组不存在为止，表示查找不成功。

注意：若数组初始无序，需要先对其进行排序，再进行查找。

### 2.3.3 流程

1. 确定查找的范围 最小->最大

2. 计算中间下标(最小+最大)/2

3. 比较中间下标数据，中间数据较大，则最大下标等于中间下标-1；

   比较中间下标数据，中间数据较小，则最小下标等于中间下标+1

4. 重新计算中间下标

5. 比较数据...

   当最小下标大于最大下标时，表明数据不存在，查找失败

### 2.3.4 代码

```java
int[] nums = {10,20,30,40,50,60,70,80};
// 要查找的数据
int num = 30;
// 关键的三个变量
// 1. 最小范围下标
int minIndex = 0;
// 2. 最大范围下标
int maxIndex = nums.length-1;
// 3. 中间数据下标
int centerIndex = (minIndex + maxIndex)/2;
// 不能确定循环次数，故不能用for
while(true){
    // 验证查找效率
    System.out.println("循环了一次");
    if(nums[centerIndex] > num){
        // 中间数据较大
        maxIndex = centerIndex - 1;
    } else if(nums[centerIndex] < num){
        // 中间数据较小
        minIndex = centerIndex + 1;
    } else {
        // 找到了数据 数据位置：centerIndex
        break; // 跳出循环
    }
    // 找不到数据，将centerIndex赋值为-1
    if(minIndex > maxIndex){
        centerIndex = -1;
        break; // 跳出循环
    }
    // 当边界发生变化时，需要更新中间下标
    centerIndex = (minIndex + maxIndex)/2;
}
System.out.println("位置：" + centerIndex);
```

# 3. 多维数组

数组的元素也是数组；

很少使用二维以上的数组；

一种可能的应用场景：进行全国的省份、市、县、城镇、街道的地图数据存储时，通常会使用多维数组。以一种包含关系来看。

```
// 多维数组的创建格式
// 数据类型 数组名 = new 数据类型[长度];
// int[][] 二维数组名称 = new int[长度][];
// 内层数组长度可以不同（不固定）
// 若内层设定长度，则会将第二维数组长度固定

int[][] nums = new int[10][];
nums[0] = new int[] {1,2,3};

// 访问二维数组的元素
System.out.println(nums[0][2]);
```

